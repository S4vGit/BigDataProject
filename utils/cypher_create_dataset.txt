// FIRST PART: node "Tweet" creation
LOAD CSV WITH HEADERS FROM 'file:///ds_obama_final.csv' AS row

MERGE (t:Tweet {
  date: row.Date,
  text: row.`Tweet-text`
})
SET t.retweets = toInteger(row.Retweets),
    t.likes = toInteger(row.Likes),
    t.topic = row.topic,
    t.confidence = toFloat(row.confidence),
    t.sentiment = row.sentiment,
    t.sentiment_confidence = toFloat(row.sentiment_confidence);
	
// SECOND PART: node "Entity" creation and relation "MENTIONS" creation
	
LOAD CSV WITH HEADERS FROM 'file:///ds_obama_final.csv' AS row

// Pulizia iniziale (rimuove parentesi quadre esterne e dividi ogni entità con '],[')
WITH row, replace(replace(replace(row.entities, "[[", ""), "]]", ""), "'],['", "|") AS cleaned

// Rimuove eventuali altri caratteri non necessari
WITH row, replace(replace(cleaned, "[", ""), "]", "") AS flat

// Splitta tra le entità usando il separatore personalizzato "|"
WITH row, split(flat, "|") AS entityStrings

UNWIND entityStrings AS eString

// Ora ogni eString è del tipo "'NBA' 'ORG'"
WITH row, trim(eString) AS raw

// Splitta tra nome e tipo usando lo spazio
WITH row, split(raw, "' '") AS parts
WHERE size(parts) = 2  // scarta quelle malformate

// Pulisce i singoli campi
WITH row, replace(parts[0], "'", "") AS name, replace(parts[1], "'", "") AS type
WHERE name <> "" AND type <> ""

MERGE (e:Entity {name: name, type: type})

// Collega l'entità al tweet
WITH row, e
MATCH (t:Tweet {date: row.Date, text: row.`Tweet-text`})
MERGE (t)-[:MENTIONS]->(e);
